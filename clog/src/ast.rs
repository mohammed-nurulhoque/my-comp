//! The AST generated by the parser.

use crate::types::{ProtoType, Literal, BinOpcode, UnOpcode};

/// A top level declaration, which is a value or a type declaration
#[derive(Debug)]
pub enum Binding<'input> {
    /// A type declaration
    Type {
        /// name to bind the type to
        name: &'input str, 
        /// names of generics
        vars: Vec<&'input str>,
        /// variants' names and arguments' types
        variants: Vec<(&'input str, ProtoType<'input>)> },
    /// A value binding, bool for is recursive?
    Value(Pattern<'input>, Expr<'input>, bool),
    Method(&'input str, &'input str, Expr<'input>)
}

/// A pattern or LHS of a binding to match
#[derive(Debug)]
pub enum Pattern<'input> {
    /// Wild card matches everything
    Wild,
    /// matches a concrete value, e.g. a number or a string
    Literal(Literal<'input>),
    /// Binds any matched expression to a name
    Bind(&'input str),
    /// matches a tuple (recursively)
    Tuple(Vec<Pattern<'input>>),
    /// matches a variant of a sum type and its argument with leading path
    SumVar(&'input str, Box<Pattern<'input>>),
    /// Parse error
    Error(usize, usize),
}

/// An expression or RHS that evaluates to a value,
#[derive(Debug)]
pub enum Expr<'input> {
    /// a value literal e.g int, string
    Literal(Literal<'input>),
    /// value of a name that was previously bound with leading path
    Bound(&'input str),
    /// a tuple of values
    Tuple(Vec<Expr<'input>>),

    /// the value of applying a binary operation on two Exprs
    BinOp(Box<Expr<'input>>, BinOpcode, Box<Expr<'input>>),
    /// the value of applying a unary operation on an Expr
    UnOp(UnOpcode, Box<Expr<'input>>),
    Slice(Box<Expr<'input>>, Box<Expr<'input>>, Box<Expr<'input>>),

    /// A closure is a sequence of patterns and corresponsing expressions
    Closure(Vec<(Vec<Pattern<'input>>, Expr<'input>)>),
    /// Apply an expression on an expression,
    /// including constructing values of sum types
    Application(Box<Expr<'input>>, Box<Expr<'input>>),
    MethodCall(Box<Expr<'input>>, &'input str),
    /// if e1 then e2 else e3
    Conditional(Box<Expr<'input>>, Box<Expr<'input>>, Box<Expr<'input>>),
    /// Parse error
    Error(usize, usize),
}